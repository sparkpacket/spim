<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>spim-sparkpacket icon maker</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <style>
    body { 
      background:#111; 
      color:#0f0; 
      font-family: monospace; 
      text-align:center;
      margin:0;
      padding:0;
    }
    #toolbar {
      margin:10px;
      display:flex;
      flex-wrap:wrap;
      gap:5px;
      justify-content:center;
      align-items:center;
    }
    button, select, input, label {
      background:#000;
      color:#0f0;
      border:1px solid #0f0;
      padding:5px 10px;
      border-radius:4px;
      font-family: monospace;
    }
    canvas {
      border:2px solid #0f0;
      background:#222;
      touch-action:none;
      display:block;
      margin:0 auto;
    }
    input[type=range] {
      width: 100px;
    }
  </style>
</head>
<body>
<h1>spim-sparkpacket icon maker</h1>
<div id="toolbar">
  <button onclick="setTool('brush')">brush</button>
  <button onclick="setTool('eraser')">eraser</button>
  <button onclick="setTool('text')">text</button>
  <button onclick="setTool('edit')">edit text</button>
  <button onclick="setTool('drag')">drag</button>
  <button onclick="setTool('warp')">warp</button>
  <button onclick="setTool('shape')">shape</button>
  <button onclick="setTool('picker')">color picker</button>
  
  <input type="file" id="imageLoader" accept="image/*">
  
  <select id="fontSelect">
    <option>monospace</option>
    <option>serif</option>
    <option>sans-serif</option>
    <option>cursive</option>
  </select>
  
  <input type="color" id="colorPicker" value="#00ff00">
  <label>Size: <input type="range" id="sizeRange" min="1" max="50" value="5"></label>
  <label>Shape thickness: <input type="range" id="shapeRange" min="1" max="50" value="2"></label>
  <select id="shapeFill">
    <option value="stroke">Outline</option>
    <option value="fill">Filled</option>
  </select>

  <!-- New width/height inputs -->
  <label>Canvas W: <input type="number" id="canvasWidth" value="1024" min="1"></label>
  <label>Canvas H: <input type="number" id="canvasHeight" value="576" min="1"></label>
  <button onclick="resizeCanvas()">resize</button>

  <button onclick="downloadImage()">download</button>
</div>
<canvas id="canvas" width="1024" height="576"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let tool = "brush";
let drawing = false;
let objects = [];
let selectedObject = null;
let offsetX, offsetY;
let startX, startY;

function setTool(t) {
  tool = t;
  selectedObject = null;
}

canvas.addEventListener("mousedown", startAction);
canvas.addEventListener("mousemove", doAction);
canvas.addEventListener("mouseup", endAction);
canvas.addEventListener("touchstart", e => startAction(e.touches[0]));
canvas.addEventListener("touchmove", e => { doAction(e.touches[0]); e.preventDefault(); });
canvas.addEventListener("touchend", endAction);

document.getElementById("imageLoader").addEventListener("change", handleImage);

function handleImage(e) {
  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      objects.push({type:"image", img, x:50, y:50, width:img.width/2, height:img.height/2, scaleX:1, scaleY:1});
      redraw();
    }
    img.src = event.target.result;
  }
  reader.readAsDataURL(e.target.files[0]);
}

function startAction(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  startX = x;
  startY = y;

  const color = document.getElementById("colorPicker").value;
  const size = parseInt(document.getElementById("sizeRange").value);

  if (tool === "brush") {
    drawing = true;
    objects.push({type:"brush", points:[{x,y}], color, size});
  } else if (tool === "eraser") {
    drawing = true;
    objects.push({type:"eraser", points:[{x,y}], size});
  } else if (tool === "text") {
    const text = prompt("Enter text:");
    if(text){
      objects.push({type:"text", text, x, y, font:document.getElementById("fontSelect").value, color, scaleX:1, scaleY:1});
      redraw();
    }
  } else if(tool === "edit") {
    selectedObject = objects.find(o => o.type==="text" && x>o.x && x<o.x+100 && y>o.y-30 && y<o.y+30);
    if(selectedObject){
      const newText = prompt("Edit text:", selectedObject.text);
      if(newText!==null) selectedObject.text = newText;
      redraw();
    }
  } else if(tool === "drag" || tool === "warp") {
    selectedObject = objects.find(o => {
      if(o.type==="text") return x>o.x && x<o.x+100 && y>o.y-30 && y<o.y+30;
      if(o.type==="image") return x>o.x && x<o.x+o.width && y>o.y && y<o.y+o.height;
      if(o.type==="shape") return x>o.x && x<o.x+o.width && y>o.y && y<o.y+o.height;
      return false;
    });
    if(selectedObject){
      offsetX = x - selectedObject.x;
      offsetY = y - selectedObject.y;
    }
  } else if(tool==="shape") {
    objects.push({type:"shape", x, y, width:0, height:0, color, size:parseInt(document.getElementById("shapeRange").value), fill:document.getElementById("shapeFill").value, shape:"rect"});
  } else if(tool==="picker"){
    const imageData = ctx.getImageData(x, y,1,1).data;
    const hex = `#${((1 << 24) + (imageData[0]<<16) + (imageData[1]<<8) + imageData[2]).toString(16).slice(1)}`;
    document.getElementById("colorPicker").value = hex;
  }
}

function doAction(e){
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if(drawing){
    let obj = objects[objects.length-1];
    if(tool==="brush" || tool==="eraser") obj.points.push({x,y});
    redraw();
  } else if((tool==="drag" || tool==="warp") && selectedObject){
    if(tool==="drag"){
      selectedObject.x = x - offsetX;
      selectedObject.y = y - offsetY;
    } else if(tool==="warp" && selectedObject.type==="text"){
      selectedObject.scaleX = (x - selectedObject.x)/100;
      selectedObject.scaleY = (y - selectedObject.y)/30;
    } else if(tool==="warp" && selectedObject.type==="image"){
      selectedObject.scaleX = (x - selectedObject.x)/selectedObject.width;
      selectedObject.scaleY = (y - selectedObject.y)/selectedObject.height;
    } else if(tool==="warp" && selectedObject.type==="shape"){
      selectedObject.width = x - selectedObject.x;
      selectedObject.height = y - selectedObject.y;
    }
    redraw();
  } else if(tool==="shape"){
    let obj = objects[objects.length-1];
    obj.width = x - startX;
    obj.height = y - startY;
    redraw();
  }
}

function endAction(){
  drawing=false;
  selectedObject=null;
}

function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let obj of objects){
    if(obj.type==="brush"){
      ctx.strokeStyle=obj.color;
      ctx.lineWidth=obj.size;
      ctx.beginPath();
      ctx.moveTo(obj.points[0].x,obj.points[0].y);
      for(let p of obj.points) ctx.lineTo(p.x,p.y);
      ctx.stroke();
    } else if(obj.type==="eraser"){
      ctx.strokeStyle="#222";
      ctx.lineWidth=obj.size;
      ctx.beginPath();
      ctx.moveTo(obj.points[0].x,obj.points[0].y);
      for(let p of obj.points) ctx.lineTo(p.x,p.y);
      ctx.stroke();
    } else if(obj.type==="text"){
      ctx.save();
      ctx.translate(obj.x,obj.y);
      ctx.scale(obj.scaleX,obj.scaleY);
      ctx.font=`20px ${obj.font}`;
      ctx.fillStyle=obj.color;
      ctx.fillText(obj.text,0,0);
      ctx.restore();
    } else if(obj.type==="image"){
      ctx.save();
      ctx.translate(obj.x,obj.y);
      ctx.scale(obj.scaleX,obj.scaleY);
      ctx.drawImage(obj.img,0,0,obj.width,obj.height);
      ctx.restore();
    } else if(obj.type==="shape"){
      ctx.beginPath();
      if(obj.fill==="fill"){
        ctx.fillStyle=obj.color;
        ctx.fillRect(obj.x,obj.y,obj.width,obj.height);
      } else {
        ctx.strokeStyle=obj.color;
        ctx.lineWidth=obj.size;
        ctx.strokeRect(obj.x,obj.y,obj.width,obj.height);
      }
    }
  }
}

// ðŸ”¹ New: resize canvas while preserving objects
function resizeCanvas(){
  const newWidth = parseInt(document.getElementById("canvasWidth").value);
  const newHeight = parseInt(document.getElementById("canvasHeight").value);

  canvas.width = newWidth;
  canvas.height = newHeight;

  redraw(); // re-render stored objects at new size
}

function downloadImage(){
  canvas.toBlob(blob => {
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "favicon.png";
    link.click();
  }, "image/png");
}
</script>
</body>
</html>
